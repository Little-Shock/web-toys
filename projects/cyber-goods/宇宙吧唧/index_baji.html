<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>宇宙吧唧 (Cosmic Baji)</title>
    <style>
        :root {
            --gravity-x: 0;
            --gravity-y: 0;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000000;
            margin: 0;
            perspective: 1000px;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        /* 返回按钮样式 */
        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-size: 14px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            color: white;
            background: rgba(0, 0, 0, 0.5);
        }

        /* 控制按钮样式 */
        .upload-container {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .upload-button {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            margin-bottom: 8px;
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .upload-button:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .upload-icon {
            margin-right: 6px;
            font-size: 14px;
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            .upload-button {
                padding: 6px 12px;
                font-size: 11px;
                max-width: 130px;
            }

            .upload-icon {
                font-size: 12px;
            }
        }

        /* 加载动画 */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }

        /* 调试面板样式 */
        .debug-panel {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 1000;
            display: none;
            max-width: 200px;
        }

        .debug-panel.active {
            display: block;
        }

        .debug-panel input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .debug-panel button {
            background: rgba(98, 0, 234, 0.4);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin-top: 5px;
            cursor: pointer;
        }

        .debug-panel button:hover {
            background: rgba(98, 0, 234, 0.6);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 粒子背景效果 */
        .particle-container {
            position: absolute;
            width: 375px;
            height: 375px;
            transform-style: preserve-3d;
            perspective: 1000px;
            animation: rotate 20s infinite linear;
            z-index: 0;
        }

        @keyframes rotate {
            100% {
                transform: rotateY(360deg) rotateX(360deg);
            }
        }

        .particle {
            position: absolute;
            width: 2.5px;  /* 默认粒子大小减小 */
            height: 2.5px;
            border-radius: 50%;
            opacity: 0;
            transform-origin: center center;
        }

        /* 粒子爆炸动画 */
        @keyframes particleExplosion {
            0% {
                transform: translate3d(0, 0, 0);
                opacity: 0.8;
            }
            100% {
                transform: translate3d(
                    calc(var(--expX) * 500px),
                    calc(var(--expY) * 500px),
                    calc(var(--expZ) * 500px)
                );
                opacity: 0;
            }
        }

        .particle.exploding {
            animation: particleExplosion 1.5s ease-out forwards !important;
        }

        .baji-container {
            width: 375px;
            height: 375px;
            perspective: 1000px; /* 确保有透视效果 */
            background-color: transparent; /* 使背景透明，显示粒子 */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .baji {
            width: 250px;
            height: 250px;
            position: relative;
            cursor: pointer;
            border-radius: 50%;
            transform-style: preserve-3d;
            box-shadow: 0 0 20px rgba(255,255,255,0.35), 2px 5px 18px rgba(255,255,255,0.3);
        }

        .baji-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden; /* 确保在Safari中也生效 */
            display: flex;
            justify-content: center;
            align-items: center;
            transform-style: preserve-3d; /* 确保3D效果保持 */
        }

        .baji-face img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            border-radius: 50%;
            user-select: none;  /* 防止内容被选中 */
        }

        .baji-front {
            /* 正面不需要特殊变换 */
            z-index: 2; /* 确保正面在上层 */
            transform: translateZ(0.1px); /* 微小的Z轴偏移，确保在3D空间中正确渲染 */
            position: relative; /* 为碎片容器定位 */
        }

        .baji-back {
            transform: rotateY(180deg);
            z-index: 1;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: 50%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        /* 修复背面图片定位 */
        .baji-back img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            transform: none !important;
            backface-visibility: visible;
        }

        /* 确保背面元素的效果在图片上方 */
        .baji-back .emboss-overlay,
        .baji-back .edge-light {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            z-index: 2; /* 确保在图片上方 */
            pointer-events: none; /* 不干扰鼠标事件 */
        }

        /* --- Effects CSS --- */
        .emboss-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%;
            box-shadow: inset 0 6px 12px rgba(255,255,255,0.8), inset 0 -6px 12px rgba(0,0,0,0.4), inset 6px 0 12px rgba(255,255,255,0.4), inset -6px 0 12px rgba(0,0,0,0.4);
            pointer-events: none; z-index: 2;
        }
        .highlight-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%;
            background: radial-gradient(circle at 25% 25%, rgba(255,255,255,0.85) 0%, rgba(255,255,255,0.5) 15%, rgba(255,255,255,0.2) 30%, rgba(255,255,255,0) 50%);
            pointer-events: none; z-index: 1;
        }
        .top-light {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%;
            background: linear-gradient(120deg, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.4) 15%, transparent 35%);
            pointer-events: none; z-index: 3;
            opacity: 0.6;
        }
        .edge-light {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%;
            box-shadow: inset -10px -10px 20px rgba(0,0,0,0.15), inset 10px 10px 20px rgba(255,255,255,0.3);
            pointer-events: none; z-index: 1;
        }
        /* --- End of effects CSS --- */

        /* --- 碎片效果 CSS --- */
        .shards-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
            z-index: 2;
            mix-blend-mode: screen;
        }

        .shard {
            position: absolute;
            pointer-events: none;
            transform-origin: center center;
        }

        .shard-enhanced {
            position: absolute;
            pointer-events: none;
            transform-origin: center center;
            box-shadow: 0 0 4px 2px rgba(255, 255, 255, 0.7);
        }
        /* --- End of 碎片效果 CSS --- */

        /* --- Micro-motion (Sway) Animation --- */
        @keyframes sway-animation {
            0% { transform: rotateY(-12deg) rotateX(4deg); }
            50% { transform: rotateY(12deg) rotateX(-4deg); }
            100% { transform: rotateY(-12deg) rotateX(4deg); }
        }

        .baji.default-sway {
            animation: sway-animation 4s ease-in-out infinite;
        }

        /* 当使用重力感应时，停止默认动画 */
        .baji.gyro-active {
            animation: none;
        }
        /* --- End of Sway Animation --- */

        /* --- 光线变幻效果 --- */
        .dynamic-light {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            opacity: 0.5;
            pointer-events: none;
            z-index: 4;
            mix-blend-mode: overlay;
            transition: all 0.1s ease-out;
        }
        /* --- End of 光线变幻效果 --- */

        /* --- Single Click 360 Spin Animation --- */
        @keyframes spin-360 {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(360deg); }
        }

        .baji.perform-spin {
            animation: spin-360 1s ease-in-out;
        }
        /* --- End of Single Click Spin Animation --- */

    </style>
</head>
<body>
    <!-- 返回主菜单链接 -->
    <a href="../../../index.html" class="back-link">返回主菜单</a>

    <!-- 粒子特效容器 -->
    <div class="particle-container" id="particleContainer"></div>

    <div class="baji-container">
        <div class="baji default-sway" id="baji">
            <div class="baji-face baji-front">
                <img src="https://oss.talesofai.cn/fe_assets/mng/17/f29f43ac4481bb4de8278ad6a73c04d3.jpg" alt="吧唧正面" id="frontImage">
                <div class="shards-container" id="shardsContainer"></div>
                <div class="emboss-overlay" id="embossOverlayFront"></div>
                <div class="highlight-overlay" id="highlightOverlayFront"></div>
                <div class="top-light" id="topLightFront"></div>
                <div class="edge-light" id="edgeLightFront"></div>
                <div class="dynamic-light" id="dynamicLightFront"></div>
            </div>
            <div class="baji-face baji-back">
                <img src="https://oss.talesofai.cn/fe_assets/mng/17/1c0b32094074e69513e3fa897d8325ed.jpg" alt="吧唧背面" id="backImage">
                <div class="emboss-overlay"></div>
                <div class="edge-light"></div>
            </div>
        </div>
    </div>

    <!-- 控制按钮容器 -->
    <div class="upload-container">
        <button class="upload-button" id="uploadButton" style="margin-bottom: 10px;">
            <span class="upload-icon">📷</span>
            <span>上传自定义图片</span>
        </button>
        <button class="upload-button" id="gyroButton" style="background: rgba(98, 0, 234, 0.2); margin-bottom: 10px;">
            <span class="upload-icon">📱</span>
            <span id="gyroButtonText">开启重力感应</span>
        </button>
        <button class="upload-button" id="debugButton" style="background: rgba(0, 0, 0, 0.2);">
            <span class="upload-icon">⚙️</span>
            <span>调试设置</span>
        </button>
        <input type="file" id="imageUpload" accept="image/*" style="display: none;">
    </div>

    <!-- 加载动画 -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
    </div>

    <!-- 调试面板 -->
    <div class="debug-panel" id="debugPanel">
        <div>持握角度调整: <span id="betaAngleValue">50</span>°</div>
        <input type="range" id="betaAngleSlider" min="30" max="70" value="50" step="1">
        <div id="deviceInfo"></div>
        <button id="toggleDebugBtn">关闭调试</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const bajiElement = document.getElementById('baji');
            const shardsContainer = document.getElementById('shardsContainer');
            const particleContainer = document.getElementById('particleContainer');
            const uploadButton = document.getElementById('uploadButton');
            const gyroButton = document.getElementById('gyroButton');
            const gyroButtonText = document.getElementById('gyroButtonText');
            const imageUpload = document.getElementById('imageUpload');
            const frontImage = document.getElementById('frontImage');
            const backImage = document.getElementById('backImage');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const dynamicLightFront = document.getElementById('dynamicLightFront');

            // 调试相关元素
            const debugButton = document.getElementById('debugButton');
            const debugPanel = document.getElementById('debugPanel');
            const betaAngleSlider = document.getElementById('betaAngleSlider');
            const betaAngleValue = document.getElementById('betaAngleValue');
            const deviceInfo = document.getElementById('deviceInfo');
            const toggleDebugBtn = document.getElementById('toggleDebugBtn');

            // 重力感应状态
            let gyroActive = false;
            let gyroPermissionGranted = false;

            // 用户持握角度偏好 (默认为50度)
            let preferredBetaAngle = 50;

            // 保存上传的图片URL
            let customImageUrl = null;

            // 是否显示调试信息
            let showDebugInfo = false;

            // 返回按钮链接由back-link-fix-new.js处理
            // 不再需要这里的代码

            // 检测是否为移动设备
            function isMobileDevice() {
                return (window.innerWidth <= 768) ||
                       /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            // 检查是否是iOS设备
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

            // 更新iOS设备上的按钮文本
            if (isIOS && window.DeviceOrientationEvent &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                gyroButtonText.textContent = '点击启用重力感应';
            }

            // 在移动设备上自动启用重力感应（仅Android设备）
            if (isMobileDevice()) {
                // 延迟一点启动重力感应，确保页面完全加载
                setTimeout(() => {
                    // 如果不是iOS设备，自动启用重力感应
                    // iOS设备需要用户手动点击按钮启用，避免权限弹窗导致问题
                    if (!isIOS && window.DeviceOrientationEvent &&
                        typeof DeviceOrientationEvent.requestPermission !== 'function') {
                        activateGyroscope();
                    }
                }, 1000);
            }

            // 处理上传按钮点击
            uploadButton.addEventListener('click', function() {
                imageUpload.click();
            });

            // 处理重力感应按钮点击
            gyroButton.addEventListener('click', function() {
                if (!gyroActive) {
                    // 尝试启用重力感应
                    enableGyroscope();
                } else {
                    // 禁用重力感应
                    disableGyroscope();
                }
            });

            // 处理调试按钮点击
            debugButton.addEventListener('click', function() {
                toggleDebugPanel();
            });

            // 处理调试面板中的角度滑块变化
            betaAngleSlider.addEventListener('input', function() {
                preferredBetaAngle = parseInt(this.value);
                betaAngleValue.textContent = preferredBetaAngle;
                // 如果重力感应已激活，立即应用新的角度设置
                if (gyroActive) {
                    // 触发一次方向事件处理，应用新设置
                    const lastOrientationEvent = window.lastOrientationEvent;
                    if (lastOrientationEvent) {
                        handleOrientation(lastOrientationEvent);
                    }
                }
            });

            // 处理调试面板中的切换按钮
            toggleDebugBtn.addEventListener('click', function() {
                toggleDebugPanel();
            });

            // 切换调试面板显示/隐藏
            function toggleDebugPanel() {
                showDebugInfo = !showDebugInfo;
                debugPanel.classList.toggle('active', showDebugInfo);
                debugButton.style.background = showDebugInfo ?
                    'rgba(0, 0, 0, 0.6)' : 'rgba(0, 0, 0, 0.2)';

                // 更新按钮文本
                toggleDebugBtn.textContent = showDebugInfo ? '关闭调试' : '开启调试';
            }

            // 启用重力感应
            function enableGyroscope() {
                // 检查设备是否支持DeviceOrientation事件
                if (window.DeviceOrientationEvent) {
                    // 检查是否需要请求权限（iOS 13+）
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    // 权限已授予，启用重力感应
                                    activateGyroscope();
                                } else {
                                    alert('需要重力感应权限才能启用此功能');
                                }
                            })
                            .catch(error => {
                                console.error('获取重力感应权限失败:', error);
                                alert('无法获取重力感应权限');
                            });
                    } else {
                        // 不需要请求权限的设备（Android等）
                        activateGyroscope();
                    }
                } else {
                    alert('您的设备不支持重力感应功能');
                }
            }

            // 激活重力感应
            function activateGyroscope() {
                gyroActive = true;
                gyroPermissionGranted = true;

                // 更新按钮状态
                gyroButton.style.background = 'rgba(98, 0, 234, 0.6)';
                gyroButton.querySelector('span:last-child').textContent = '关闭重力感应';

                // 添加gyro-active类，停止默认动画
                bajiElement.classList.remove('default-sway');
                bajiElement.classList.add('gyro-active');

                // 添加设备方向事件监听器
                window.addEventListener('deviceorientation', handleOrientation);

                // 添加屏幕方向变化监听器，以便在设备旋转时调整显示
                window.addEventListener('resize', handleScreenOrientationChange);

                // 如果浏览器支持屏幕方向变化事件，也添加这个监听器
                if (window.screen && window.screen.orientation) {
                    window.screen.orientation.addEventListener('change', handleScreenOrientationChange);
                } else if (window.orientation !== undefined) {
                    // 旧版API支持
                    window.addEventListener('orientationchange', handleScreenOrientationChange);
                }
            }

            // 禁用重力感应
            function disableGyroscope() {
                gyroActive = false;

                // 更新按钮状态
                gyroButton.style.background = 'rgba(98, 0, 234, 0.2)';
                gyroButton.querySelector('span:last-child').textContent = '开启重力感应';

                // 移除gyro-active类，恢复默认动画
                bajiElement.classList.remove('gyro-active');
                bajiElement.classList.add('default-sway');

                // 重置吧唧和光线效果的位置
                bajiElement.style.transform = '';
                dynamicLightFront.style.background = 'radial-gradient(circle at 50% 50%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)';

                // 移除设备方向事件监听器
                window.removeEventListener('deviceorientation', handleOrientation);

                // 移除屏幕方向变化监听器
                window.removeEventListener('resize', handleScreenOrientationChange);

                // 移除屏幕方向变化的专用事件监听器
                if (window.screen && window.screen.orientation) {
                    window.screen.orientation.removeEventListener('change', handleScreenOrientationChange);
                } else if (window.orientation !== undefined) {
                    window.removeEventListener('orientationchange', handleScreenOrientationChange);
                }
            }

            // 处理屏幕方向变化
            function handleScreenOrientationChange() {
                // 当屏幕尺寸变化时，可能是设备旋转，重新应用当前的方向数据
                if (gyroActive) {
                    // 重置吧唧位置，等待下一次设备方向事件更新
                    bajiElement.style.transform = '';
                    dynamicLightFront.style.background = 'radial-gradient(circle at 50% 50%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)';
                }
            }

            // 检测屏幕方向（竖屏/横屏）
            function isPortraitMode() {
                return window.innerHeight > window.innerWidth;
            }

            // 处理设备方向变化
            function handleOrientation(event) {
                if (!gyroActive) return;

                // 保存最后一次方向事件，用于调试面板调整时重新应用
                window.lastOrientationEvent = event;

                // 获取设备方向数据
                const beta = event.beta;  // X轴旋转 (-180 到 180)
                const gamma = event.gamma; // Y轴旋转 (-90 到 90)
                const alpha = event.alpha; // Z轴旋转 (0 到 360)

                // 检查是否为竖屏模式
                const isPortrait = isPortraitMode();

                // 限制倾斜角度范围
                const maxTilt = 15;

                let tiltX, tiltY;

                if (isPortrait) {
                    // 竖屏模式下的坐标映射调整
                    // 在竖屏模式下，我们希望设备正面朝向用户时显示吧唧的正面

                    // gamma对应左右倾斜 (-90 到 90)
                    // 保持左右倾斜的映射不变
                    tiltX = Math.max(-maxTilt, Math.min(maxTilt, gamma));

                    // beta对应前后倾斜 (-180 到 180)
                    // 使用用户设置的持握角度作为基准点
                    const betaOffset = preferredBetaAngle; // 使用用户设置的角度
                    const adjustedBeta = beta - betaOffset;

                    // 限制调整后的beta值范围，并反转方向使其更直观
                    // 当设备向前倾斜时，吧唧向上倾斜；向后倾斜时，吧唧向下倾斜
                    tiltY = Math.max(-maxTilt, Math.min(maxTilt, -adjustedBeta));
                } else {
                    // 横屏模式下的处理方式
                    // 在横屏模式下，我们可能需要不同的映射
                    tiltX = Math.max(-maxTilt, Math.min(maxTilt, gamma));

                    // 在横屏模式下，beta=0时设备平放，我们希望显示吧唧正面
                    tiltY = Math.max(-maxTilt, Math.min(maxTilt, beta));
                }

                // 应用倾斜效果到吧唧
                bajiElement.style.transform = `rotateY(${tiltX}deg) rotateX(${-tiltY}deg)`;

                // 计算光线位置（根据倾斜角度移动光源）
                const lightPosX = 50 + (tiltX / maxTilt) * 30; // 30%的移动范围
                const lightPosY = 50 + (tiltY / maxTilt) * 30;

                // 更新动态光线效果
                dynamicLightFront.style.background = `radial-gradient(circle at ${lightPosX}% ${lightPosY}%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)`;

                // 根据倾斜角度调整粒子行为（轻微影响）
                updateParticlesWithTilt(tiltX, tiltY);

                // 如果调试面板打开，更新设备信息
                if (showDebugInfo && deviceInfo) {
                    deviceInfo.innerHTML = `
                        <div style="margin-top: 8px;">设备方向数据:</div>
                        <div>Beta: ${beta.toFixed(1)}°</div>
                        <div>Gamma: ${gamma.toFixed(1)}°</div>
                        <div>调整后Beta: ${(beta - preferredBetaAngle).toFixed(1)}°</div>
                        <div>屏幕模式: ${isPortrait ? '竖屏' : '横屏'}</div>
                    `;
                }
            }

            // 根据倾斜角度更新粒子行为
            function updateParticlesWithTilt(tiltX, tiltY) {
                // 计算倾斜方向的重力影响
                const gravityX = tiltX / 15; // 归一化到 -1 到 1 的范围
                const gravityY = tiltY / 15;

                // 更新粒子容器的变换，创造微妙的整体移动效果
                particleContainer.style.transform = `translate(${gravityX * 5}px, ${gravityY * 5}px)`;

                // 为粒子添加一个微妙的CSS变量，可以在动画中使用
                document.documentElement.style.setProperty('--gravity-x', gravityX);
                document.documentElement.style.setProperty('--gravity-y', gravityY);

                // 光线强度随倾斜角度变化
                const tiltMagnitude = Math.sqrt(tiltX * tiltX + tiltY * tiltY) / 15; // 0-1范围
                const lightIntensity = 0.5 + tiltMagnitude * 0.3; // 0.5-0.8范围

                // 更新动态光线的强度
                dynamicLightFront.style.opacity = lightIntensity;
            }

            // 处理图片上传
            imageUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;

                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择有效的图片文件');
                    return;
                }

                // 显示加载动画
                loadingOverlay.classList.add('active');

                // 创建图片URL
                const url = URL.createObjectURL(file);

                // 保存上传的图片URL
                customImageUrl = url;

                // 创建新图像对象用于预加载
                const img = new Image();
                img.onload = function() {
                    // 只更新正面图片，保留原始的背面图片（带别针的效果）
                    frontImage.src = customImageUrl;

                    // 确保背面图片样式正确应用
                    backImage.style.position = 'absolute';
                    backImage.style.top = '0';
                    backImage.style.left = '0';
                    backImage.style.width = '100%';
                    backImage.style.height = '100%';
                    backImage.style.objectFit = 'cover';
                    backImage.style.borderRadius = '50%';
                    backImage.style.transform = 'none';
                    backImage.style.backfaceVisibility = 'visible';

                    // 隐藏加载动画
                    setTimeout(() => {
                        loadingOverlay.classList.remove('active');
                    }, 500);
                };

                img.onerror = function() {
                    alert('图片加载失败，请尝试其他图片');
                    loadingOverlay.classList.remove('active');
                };

                img.src = url;
            });

            // 获取视窗大小
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            // 创建背景粒子效果
            const totalParticles = 350; // 粒子总数
            const canvasSize = 375; // 画布尺寸
            const bajiSize = 250; // 吧唧尺寸
            const minOrbitSize = 140; // 最小轨道尺寸，稍大于吧唧半径
            const maxOrbitSize = 180; // 最大轨道尺寸，小于画布半径

            // 初始屏幕尺寸
            const screenSize = Math.max(windowWidth, windowHeight) * 0.7; // 使用屏幕较大尺寸的70%

            // 增强的粒子颜色数组，添加更多变化和一些亮色
            const particleColors = [
                // 原始银色和银蓝色系
                '#A0A0A0', // 暗银色
                '#B3B3B3', // 暗淡灰色
                '#C6C8DA', // 暗银蓝色
                '#90A4BE', // 暗钢蓝
                '#ACACDF', // 暗薰衣草蓝
                '#C6C6DA', // 暗薰衣草淡紫
                '#D0D8DF', // 暗爱丽丝蓝
                '#959595', // 深暗银色
                '#898989', // 暗灰色银
                '#BCBCBC', // 暗亮灰色

                // 添加一些亮色和星光色彩（低频率出现）
                '#E0E8FF', // 亮蓝白
                '#D8F0FF', // 淡天蓝
                '#E6E6FA', // 薰衣草色
                '#B0C4DE', // 亮钢蓝
                '#ADD8E6', // 亮蓝色
                '#87CEEB', // 天蓝色
                '#B0E0E6', // 粉蓝色
                '#F0FFFF', // 天蓝白
                '#E6E6FF', // 淡紫蓝
                '#F5F5FF'  // 幽灵白
            ];

            // 辅助函数: 平均分布粒子
            function getFibonacciSpherePoint(i, n, randomize = true) {
                const offset = 2.0 / n;
                const phi = Math.acos(1 - (i + 0.5) * offset);
                const theta = Math.PI * (1 + 5**0.5) * (i + (randomize ? Math.random() * 0.2 - 0.1 : 0));

                const x = Math.cos(theta) * Math.sin(phi);
                const y = Math.sin(theta) * Math.sin(phi);
                const z = Math.cos(phi);

                return { x, y, z };
            }

            // 确保样式表可访问
            const styleSheet = document.styleSheets[0];
            const definedKeyframes = new Set();

            // 辅助函数: 确保关键帧只定义一次
            function ensureKeyframe(name, rule) {
                if (!definedKeyframes.has(name)) {
                    try {
                        styleSheet.insertRule(`@keyframes ${name} { ${rule} }`, styleSheet.cssRules.length);
                        definedKeyframes.add(name);
                    } catch (e) {
                        console.warn("Could not insert keyframe (might already exist or be invalid):", name, e);
                    }
                }
            }

            // 粒子引用数组，用于爆炸效果
            const particles = [];

            // 生成粒子
            for (let i = 0; i < totalParticles; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';

                // 使用斐波那契球面分布算法获取均匀分布的点
                const point = getFibonacciSpherePoint(i, totalParticles);

                // 随机选择颜色
                const randomColor = particleColors[Math.floor(Math.random() * particleColors.length)];
                particle.style.backgroundColor = randomColor;

                // 随机轨道大小
                const orbitScale = minOrbitSize + Math.random() * (maxOrbitSize - minOrbitSize);

                // 随机粒子大小 (1.5px - 4.5px) - 增加一些变化
                const particleSize = 1.5 + Math.random() * 3.0;
                particle.style.width = `${particleSize}px`;
                particle.style.height = `${particleSize}px`;

                // 增强的光晕效果 - 添加一些更亮的粒子
                let glowIntensity;

                // 10%的粒子有更强的光晕效果
                if (Math.random() < 0.1) {
                    glowIntensity = Math.random() * 5 + 3; // 3-8px 强光晕
                    // 对于亮粒子，增加一点透明度变化
                    particle.style.opacity = 0.7 + Math.random() * 0.3;
                } else {
                    glowIntensity = Math.random() * 3 + 1; // 1-4px 普通光晕
                }

                particle.style.boxShadow = `0 0 ${glowIntensity}px ${randomColor}`;

                // 设置初始位置为画布中心
                particle.style.left = `${canvasSize / 2}px`;
                particle.style.top = `${canvasSize / 2}px`;

                // 为爆炸效果准备方向变量
                const expX = point.x;
                const expY = point.y;
                const expZ = point.z;
                particle.style.setProperty('--expX', expX);
                particle.style.setProperty('--expY', expY);
                particle.style.setProperty('--expZ', expZ);

                // 创建唯一的动画名
                const animName = `particleOrbit${i}`;

                // 设置随机动画时长 (10-20秒)
                const duration = 10 + Math.random() * 10;

                // 设置随机延迟 (0-5秒)
                const delay = Math.random() * 5;

                // 创建动画 - 从屏幕大小开始，然后收缩到轨道大小
                const keyframes = `
                    @keyframes ${animName} {
                        0%, 100% {
                            opacity: 0;
                            transform: translate3d(0, 0, 0) scale(0.3);
                        }
                        15% {
                            opacity: 0.8;
                            transform: translate3d(
                                calc(${point.x * screenSize}px + var(--gravity-x) * 10px),
                                calc(${point.y * screenSize}px + var(--gravity-y) * 10px),
                                ${point.z * screenSize}px
                            ) scale(1);
                        }
                        30% {
                            transform: translate3d(
                                calc(${point.x * orbitScale}px + var(--gravity-x) * 5px),
                                calc(${point.y * orbitScale}px + var(--gravity-y) * 5px),
                                ${point.z * orbitScale}px
                            ) scale(1);
                        }
                        70% {
                            opacity: 0.6;
                            transform: translate3d(
                                calc(${point.x * orbitScale}px + var(--gravity-x) * 5px),
                                calc(${point.y * orbitScale}px + var(--gravity-y) * 5px),
                                ${point.z * orbitScale}px
                            ) scale(1);
                        }
                        85% {
                            opacity: 0.8;
                            transform: translate3d(
                                calc(${point.x * screenSize * 0.5}px + var(--gravity-x) * 8px),
                                calc(${point.y * screenSize * 0.5}px + var(--gravity-y) * 8px),
                                ${point.z * screenSize * 0.5}px
                            ) scale(0.8);
                        }
                    }
                `;

                try {
                    styleSheet.insertRule(keyframes, styleSheet.cssRules.length);
                } catch(e) {
                    console.warn("无法插入关键帧规则:", e);
                }

                // 应用动画
                particle.style.animation = `${animName} ${duration}s infinite ease-in-out`;
                particle.style.animationDelay = `${delay}s`;

                // 添加到容器
                particleContainer.appendChild(particle);

                // 存储粒子引用
                particles.push(particle);
            }

            // 触发粒子爆炸效果
            function explodeParticles() {
                particles.forEach(particle => {
                    // 保存当前动画状态
                    const originalAnimation = particle.style.animation;
                    const originalDelay = particle.style.animationDelay;

                    // 添加爆炸动画类
                    particle.classList.add('exploding');

                    // 爆炸动画结束后恢复原来的动画
                    setTimeout(() => {
                        particle.classList.remove('exploding');
                        particle.style.animation = originalAnimation;
                        particle.style.animationDelay = originalDelay;
                    }, 1500); // 爆炸动画时长
                });
            }

            // 确保背面图片正确显示
            // 注意：backImage已经在顶部声明，这里直接使用
            if (backImage) {
                // 强制确保背面图片样式正确应用
                backImage.style.position = 'absolute';
                backImage.style.top = '0';
                backImage.style.left = '0';
                backImage.style.width = '100%';
                backImage.style.height = '100%';
                backImage.style.objectFit = 'cover';
                backImage.style.borderRadius = '50%';
                backImage.style.transform = 'none';
                backImage.style.backfaceVisibility = 'visible';
            }

            // 碎片效果 - 减少数量
            if (shardsContainer) {
                const circleRadius = 125; // 吧唧容器宽度的一半
                const numberOfShards = 66; // 减少到70个亮片

                // 简化颜色分布，主要使用白色和淡色系
                const shardColors = [
                    '#ffffff', '#ffffff', '#ffffff',
                    '#f0f8ff', '#e0ffff',
                    '#ff00ff',
                    '#00ffff',
                    '#ccffcc'
                ];

                // 定义碎片的动画
                ensureKeyframe('shardShimmer', `
                    0%, 100% { opacity: 0.4; filter: brightness(0.7) saturate(140%); transform: scale(0.85); }
                    50% { opacity: 0.9; filter: brightness(2.5) saturate(300%); transform: scale(1.15); }
                `);

                ensureKeyframe('shardDrift', `
                    0% { transform: translate(var(--tx-start, 0px), var(--ty-start, 0px)) rotate(var(--r-start, 0deg)) scale(var(--s-drift-start, 1)); }
                    50% { transform: translate(var(--tx-mid, 0px), var(--ty-mid, 0px)) rotate(var(--r-mid, 180deg)) scale(var(--s-drift-mid, 1)); }
                    100% { transform: translate(var(--tx-end, 0px), var(--ty-end, 0px)) rotate(var(--r-end, 360deg)) scale(var(--s-drift-end, 1)); }
                `);

                // 增强型亮片的闪烁动画
                ensureKeyframe('enhancedShardShimmer', `
                    0%, 100% { opacity: 0.6; filter: brightness(0.9) saturate(160%); transform: scale(0.9); }
                    50% { opacity: 1.0; filter: brightness(3.0) saturate(350%); transform: scale(1.2); }
                `);

                // 创建边缘聚集但有一些中心分布的亮片
                function getRandomPosition() {
                    const angle = Math.random() * 2 * Math.PI;
                    let r;
                    const rand = Math.random();

                    if (rand < 0.6) {
                        // 60%的亮片集中在边缘区域
                        r = (0.65 + rand * 0.3) * circleRadius;
                    } else if (rand < 0.9) {
                        // 30%的亮片分布在中间区域
                        r = (0.35 + (rand - 0.6) * 0.75) * circleRadius;
                    } else {
                        // 10%的亮片分布在中心区域
                        r = (rand - 0.9) * 3.5 * 0.35 * circleRadius;
                    }

                    const x = r * Math.cos(angle);
                    const y = r * Math.sin(angle);

                    return { x, y, r, angle };
                }

                // 创建碎片
                for (let i = 0; i < numberOfShards; i++) {
                    // 25%的几率创建增强型亮片
                    const isEnhanced = Math.random() < 0.25;

                    const shard = document.createElement('div');
                    shard.classList.add(isEnhanced ? 'shard-enhanced' : 'shard');

                    // 增强型亮片略大一些
                    const size = isEnhanced ?
                        Math.random() * 5 + 2 : // 增强型亮片 2px 到 7px
                        Math.random() * 4 + 1;  // 普通亮片 1px 到 5px

                    shard.style.width = `${size}px`;
                    shard.style.height = `${size * (Math.random() * 0.6 + 0.4)}px`; // 碎片可以更扁平

                    // 获取位置
                    const pos = getRandomPosition();

                    // 设置碎片的位置
                    shard.style.left = `calc(50% + ${pos.x}px - ${parseFloat(shard.style.width) / 2}px)`;
                    shard.style.top = `calc(50% + ${pos.y}px - ${parseFloat(shard.style.height) / 2}px)`;

                    const randomColor = shardColors[Math.floor(Math.random() * shardColors.length)];
                    shard.style.backgroundColor = randomColor;

                    // 增强型亮片有更强的光晕
                    if (isEnhanced) {
                        shard.style.boxShadow = `0 0 ${Math.random() * 4 + 2}px ${randomColor}`;
                        shard.style.opacity = '0.7';
                    } else {
                        shard.style.boxShadow = `0 0 ${Math.random() * 2 + 1}px ${randomColor}cc`;
                        shard.style.opacity = '0.6';
                    }

                    // 为每个碎片的动画设置随机参数
                    const initialRotation = Math.random() * 360;
                    const midRotation = initialRotation + (Math.random() - 0.5) * 300 + 150;
                    const endRotation = initialRotation + (Math.random() - 0.5) * 600 + 300;

                    const driftRange = 10; // 漂移范围 (px)
                    shard.style.setProperty('--r-start', `${initialRotation}deg`);
                    shard.style.setProperty('--s-drift-start', `${Math.random() * 0.3 + 0.85}`);

                    shard.style.setProperty('--tx-mid', `${(Math.random() - 0.5) * driftRange}px`);
                    shard.style.setProperty('--ty-mid', `${(Math.random() - 0.5) * driftRange}px`);
                    shard.style.setProperty('--r-mid', `${midRotation}deg`);
                    shard.style.setProperty('--s-drift-mid', `${Math.random() * 0.4 + 0.8}`);

                    shard.style.setProperty('--tx-end', `${(Math.random() - 0.5) * (driftRange * 0.6)}px`);
                    shard.style.setProperty('--ty-end', `${(Math.random() - 0.5) * (driftRange * 0.6)}px`);
                    shard.style.setProperty('--r-end', `${endRotation}deg`);
                    shard.style.setProperty('--s-drift-end', shard.style.getPropertyValue('--s-drift-start'));

                    // 使用不同的动画
                    shard.style.animationName = isEnhanced ?
                        'enhancedShardShimmer, shardDrift' :
                        'shardShimmer, shardDrift';

                    shard.style.animationTimingFunction = 'ease-in-out, cubic-bezier(0.35, 0, 0.65, 1)';
                    shard.style.animationIterationCount = 'infinite, infinite';

                    const shimmerDuration = Math.random() * 2.0 + 1.0; // 1.0s to 3.0s
                    const driftDuration = Math.random() * 12 + 10;     // 10s to 22s
                    shard.style.animationDuration = `${shimmerDuration}s, ${driftDuration}s`;
                    shard.style.animationDelay = `${Math.random() * shimmerDuration * -1}s, ${Math.random() * driftDuration * -1}s`;

                    shardsContainer.appendChild(shard);
                }

                // 添加少量特别明亮的大亮片
                for (let i = 0; i < 4; i++) { // 减少到4个大亮片
                    const bigShard = document.createElement('div');
                    bigShard.classList.add('shard-enhanced');

                    const size = Math.random() * 6 + 4; // 4px 到 10px
                    bigShard.style.width = `${size}px`;
                    bigShard.style.height = `${size * (Math.random() * 0.5 + 0.5)}px`;

                    // 随机位置
                    const angle = Math.random() * 2 * Math.PI;
                    let r;

                    if (i < 2) { // 2个在边缘
                        r = (0.6 + Math.random() * 0.3) * (circleRadius - size * 2);
                    } else { // 2个在中心区域
                        r = Math.random() * 0.6 * (circleRadius - size * 2);
                    }

                    const x = r * Math.cos(angle);
                    const y = r * Math.sin(angle);

                    bigShard.style.left = `calc(50% + ${x}px - ${size / 2}px)`;
                    bigShard.style.top = `calc(50% + ${y}px - ${size / 2}px)`;

                    // 随机颜色，只使用白色和淡蓝色
                    const brightColors = ['#ffffff', '#ffffff', '#f0f8ff', '#e0ffff'];
                    const randomColor = brightColors[Math.floor(Math.random() * brightColors.length)];
                    bigShard.style.backgroundColor = randomColor;
                    bigShard.style.boxShadow = `0 0 ${Math.random() * 5 + 3}px ${randomColor}`;
                    bigShard.style.opacity = '0.85';

                    // 动画参数
                    const initialRotation = Math.random() * 360;
                    const midRotation = initialRotation + (Math.random() - 0.5) * 200 + 100;
                    const endRotation = initialRotation + (Math.random() - 0.5) * 400 + 200;

                    const driftRange = 8;
                    bigShard.style.setProperty('--r-start', `${initialRotation}deg`);
                    bigShard.style.setProperty('--s-drift-start', `${Math.random() * 0.2 + 0.9}`);

                    bigShard.style.setProperty('--tx-mid', `${(Math.random() - 0.5) * driftRange}px`);
                    bigShard.style.setProperty('--ty-mid', `${(Math.random() - 0.5) * driftRange}px`);
                    bigShard.style.setProperty('--r-mid', `${midRotation}deg`);
                    bigShard.style.setProperty('--s-drift-mid', `${Math.random() * 0.3 + 0.85}`);

                    bigShard.style.setProperty('--tx-end', `${(Math.random() - 0.5) * (driftRange * 0.6)}px`);
                    bigShard.style.setProperty('--ty-end', `${(Math.random() - 0.5) * (driftRange * 0.6)}px`);
                    bigShard.style.setProperty('--r-end', `${endRotation}deg`);
                    bigShard.style.setProperty('--s-drift-end', bigShard.style.getPropertyValue('--s-drift-start'));

                    bigShard.style.animationName = 'enhancedShardShimmer, shardDrift';
                    bigShard.style.animationTimingFunction = 'ease-in-out, cubic-bezier(0.35, 0, 0.65, 1)';
                    bigShard.style.animationIterationCount = 'infinite, infinite';

                    const shimmerDuration = Math.random() * 1.5 + 0.8; // 0.8s to 2.3s
                    const driftDuration = Math.random() * 10 + 8;     // 8s to 18s
                    bigShard.style.animationDuration = `${shimmerDuration}s, ${driftDuration}s`;
                    bigShard.style.animationDelay = `${Math.random() * shimmerDuration * -1}s, ${Math.random() * driftDuration * -1}s`;

                    shardsContainer.appendChild(bigShard);
                }
            }

            // 吧唧点击旋转功能 + 粒子爆炸效果
            if (bajiElement) {
                let isSpinning = false;

                bajiElement.addEventListener('click', function() {
                    // 如果已经在旋转，则不执行新的操作
                    if (isSpinning) return;
                    isSpinning = true;

                    // 触发粒子爆炸效果
                    explodeParticles();

                    this.classList.remove('default-sway');
                    // Ensure perform-spin is not already there, then add it after reflow
                    this.classList.remove('perform-spin');
                    void this.offsetHeight; // Force reflow to restart animation
                    this.classList.add('perform-spin');
                });

                bajiElement.addEventListener('animationend', function(event) {
                    if (event.animationName === 'spin-360') {
                        this.classList.remove('perform-spin');
                        // Only add default-sway if not about to perform another spin immediately
                        if (!this.classList.contains('perform-spin')) {
                            this.classList.add('default-sway');

                            // 确保旋转后背面图片仍然正确显示，并恢复自定义图片
                            setTimeout(() => {
                                // 使用已声明的backImage变量
                                if (backImage) {
                                    backImage.style.transform = 'none';
                                }

                                // 如果有自定义图片，确保它被正确应用
                                if (customImageUrl) {
                                    frontImage.src = customImageUrl;
                                }
                            }, 50);

                            isSpinning = false;
                        }
                    }
                });
            }

        });
    </script>

    <!-- 修复返回链接的脚本 -->
    <script src="../../../js/back-link-fix-new.js"></script>
    <script src="../../../js/back-link-fix-mobile.js"></script>
</body>
</html>