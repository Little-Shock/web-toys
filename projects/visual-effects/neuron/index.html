<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Synaptic Dreams · 突触幻境</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: radial-gradient(circle at center, #0a0f2c 0%, #01011a 100%);
            font-family: 'Segoe UI', sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0; left: 0;
            z-index: -1;
        }
        .ui {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 1rem;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        .ui h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .ui p {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        .back-link {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            background: rgba(0,0,0,0.6);
            padding: 0.5rem 1rem;
            border-radius: 5px;
            color: #eee;
            text-decoration: none;
            font-size: 0.9rem;
            backdrop-filter: blur(3px);
            transition: background 0.3s;
        }
        .back-link:hover {
            background: rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <a href="/" class="back-link" id="backToHome">返回主菜单</a>
    
    <div class="ui">
        <h1>突触幻境</h1>
        <p>点击激活神经元<br>长按连接调节权重<br>轻摇设备随机激发</p>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        // === 全局配置 ===
        const CONFIG = {
            NODE_COUNT: 60,
            MAX_CONNECTIONS: 5,
            BASE_WEIGHT: 0.3,
            MAX_WEIGHT: 2,
            SIGNAL_SPEED: 0.02,
            DECAY_RATE: 0.95,
            NODE_RADIUS: 8,
            PULSE_WIDTH: 3,
            DEPTH_LAYERS: 5,
            CONNECTION_REFRESH: 5000, // ms
            SHAKETRESHOLD: 15
        };

        // === 核心类 ===
        class SynapticDreams {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.signals = [];
                this.connections = [];
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.lastShake = 0;
                this.init();
            }

            init() {
                this.setupCanvas();
                this.createNodes();
                this.connectNodes();
                this.setupEvents();
                this.animate();
            }

            setupCanvas() {
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            }

            createNodes() {
                for(let i=0; i<CONFIG.NODE_COUNT; i++) {
                    const layer = Math.floor(Math.random() * CONFIG.DEPTH_LAYERS);
                    this.nodes.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        baseX: Math.random() * this.width,
                        baseY: Math.random() * this.height,
                        radius: CONFIG.NODE_RADIUS * (0.7 + Math.random() * 0.6),
                        layer,
                        pulses: [],
                        glow: 0,
                        oscillation: Math.random() * Math.PI * 2
                    });
                }
            }

            connectNodes() {
                this.nodes.forEach(node => {
                    node.connections = [];
                    const targets = this.nodes
                        .filter(n => n !== node)
                        .sort(() => Math.random() - 0.5)
                        .slice(0, CONFIG.MAX_CONNECTIONS);
                    
                    targets.forEach(target => {
                        const weight = CONFIG.BASE_WEIGHT + Math.random() * 0.5;
                        const connection = {
                            source: node,
                            target: target,
                            baseWeight: weight,
                            weight: weight,
                            pulsePosition: 0,
                            active: false,
                            lastPulseTime: 0
                        };
                        node.connections.push(connection);
                        this.connections.push(connection);
                    });
                });
            }

            setupEvents() {
                // 点击激活
                this.canvas.addEventListener('click', e => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const clickedNode = this.findClosestNode(x, y);
                    if(clickedNode) this.activateNode(clickedNode);
                });

                // 长按调节权重
                let longPressTimer;
                this.canvas.addEventListener('mousedown', () => longPressTimer = setTimeout(() => {}, 800));
                this.canvas.addEventListener('mouseup', () => clearTimeout(longPressTimer));

                // 设备晃动
                if(window.DeviceOrientationEvent) {
                    window.addEventListener('devicemotion', e => {
                        const acc = e.accelerationIncludingGravity;
                        if(acc.x > CONFIG.SHAKETRESHOLD || 
                           acc.y > CONFIG.SHAKETRESHOLD ||
                           acc.z > CONFIG.SHAKETRESHOLD) {
                            if(Date.now() - this.lastShake > 3000) {
                                this.shakeNetwork();
                                this.lastShake = Date.now();
                            }
                        }
                    });
                }
            }

            findClosestNode(x, y) {
                return this.nodes.reduce((closest, node) => {
                    const dist = Math.hypot(node.x - x, node.y - y);
                    return dist < 50 ? node : closest;
                }, null);
            }

            activateNode(node, strength=1) {
                // 激活节点发光
                node.glow = 1;
                
                // 发射信号
                node.connections.forEach(conn => {
                    conn.active = true;
                    conn.pulsePosition = 0;
                    conn.strength = strength;
                    conn.lastPulseTime = Date.now();
                    
                    // 递归激活
                    if(strength > 0.3) {
                        setTimeout(() => {
                            this.activateNode(conn.target, strength * conn.weight * 0.7);
                        }, Math.random() * 300);
                    }
                });
            }

            shakeNetwork() {
                // 随机激活5-8个节点
                const count = 5 + Math.floor(Math.random() * 4);
                for(let i=0; i<count; i++) {
                    const node = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                    this.activateNode(node, 1 + Math.random());
                }
            }

            update() {
                // 更新节点振荡
                this.nodes.forEach(node => {
                    node.oscillation += 0.02;
                    node.x = node.baseX + Math.sin(node.oscillation) * 10;
                    node.y = node.baseY + Math.cos(node.oscillation) * 10;
                    
                    // 衰减发光
                    node.glow *= CONFIG.DECAY_RATE;
                });

                // 更新信号传播
                this.connections.forEach(conn => {
                    if(conn.active) {
                        conn.pulsePosition += CONFIG.SIGNAL_SPEED;
                        
                        // 循环脉冲
                        if(conn.pulsePosition > 1) {
                            conn.pulsePosition = 0;
                        }
                        
                        // 衰减信号
                        if(Date.now() - conn.lastPulseTime > 1000) {
                            conn.active = false;
                        }
                    }
                });
            }

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);

                // 分层绘制背景
                for(let l=0; l<CONFIG.DEPTH_LAYERS; l++) {
                    ctx.beginPath();
                    ctx.arc(this.width/2, this.height/2, 
                        200 + l*100, 0, Math.PI*2);
                    ctx.strokeStyle = `rgba(255,255,255,${0.02*(l+1)})`;
                    ctx.stroke();
                }

                // 绘制连接
                this.connections.forEach(conn => {
                    const s = conn.source;
                    const t = conn.target;
                    const dx = t.x - s.x;
                    const dy = t.y - s.y;
                    const angle = Math.atan2(dy, dx);

                    // 计算视觉属性
                    const weight = conn.weight;
                    const pulsePos = conn.pulsePosition;
                    const pulseX = s.x + dx * pulsePos;
                    const pulseY = s.y + dy * pulsePos;

                    // 绘制连接线
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(t.x, t.y);
                    ctx.strokeStyle = `hsla(
                        ${180 + weight*100}, 
                        ${70 + weight*30}%, 
                        ${40 + weight*20}%, 
                        ${weight * 0.5}
                    )`;
                    ctx.lineWidth = 1 + weight * 3;
                    ctx.stroke();

                    // 绘制脉冲点
                    if(conn.active) {
                        ctx.beginPath();
                        ctx.arc(pulseX, pulseY, CONFIG.PULSE_WIDTH, 0, Math.PI*2);
                        ctx.fillStyle = `hsla(
                            ${180 + weight*100}, 
                            100%, 
                            ${60 + weight*20}%, 
                            ${0.8 + Math.sin(Date.now()*0.01)}
                        )`;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = `hsl(${180 + weight*100}, 100%, 50%)`;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                });

                // 绘制节点
                this.nodes.forEach(node => {
                    const glow = node.glow;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius * (1 + glow), 0, Math.PI*2);
                    
                    // 渐变填充
                    const gradient = ctx.createRadialGradient(
                        node.x, node.y, node.radius * 0.2,
                        node.x, node.y, node.radius * 2
                    );
                    gradient.addColorStop(0, `rgba(255,255,255,${glow})`);
                    gradient.addColorStop(1, `rgba(100,150,255,0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // 节点本体
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI*2);
                    ctx.fillStyle = `hsla(210, 100%, ${40 + glow*60}%, 1)`;
                    ctx.fill();
                });
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // 启动游戏
        new SynapticDreams();
    </script>
<script src="../../js/back-link-fix.js"></script>
</body>
</html>